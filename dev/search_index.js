var documenterSearchIndex = {"docs":
[{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"(to be documented)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#MultiScaleOT.jl","page":"Home","title":"MultiScaleOT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiScaleOT.jl is a Julia library for solving optimal transport problems by means of a hierarchical Sinkhorn, as proposed in Schmitzer, Stabilized Sparse Scaling Algorithms for Entropy Regularized Transport Problems. It also provides routines for handling measures organized in a hierarchical manner and for refining them. It is the backbone of DomDecOT.jl, another Julia library that implements the domain decomposition algorithm for entropic optimal transport. The focus of this library is flexibility and performance. ","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [MultiScaleOT]\nOrder   = [:type, :function, :constant]","category":"page"},{"location":"internals/#MultiScaleOT.AbstractMeasure","page":"Internals","title":"MultiScaleOT.AbstractMeasure","text":"AbstractMeasure{D}\n\nType from which GridMeasure{D}, CloudMeasure{D} inherit.  It is left unexported to avoid potential conflicts with  MeasureTheory.jl, which has another type with the same name.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiScaleOT.CloudMeasure","page":"Internals","title":"MultiScaleOT.CloudMeasure","text":"CloudMeasure{D} <: AbstractMeasure{D}\n\nA measure supported on an unstructured D-dimensional point cloud. Its attributes are:\n\npoints::Matrix{Float64}: points[:,j] are the coordinates of point j.\nweights::Vector{Float64}: weights[j] is the mass of point j.\nextent::NTuple{D, Tuple{Float64, Float64}}: extent[i] are lower and upper bounds   on the i-th row of points.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiScaleOT.GridMeasure","page":"Internals","title":"MultiScaleOT.GridMeasure","text":"GridMeasure{D} <: AbstractMeasure{D}\n\nA measure supported on a D-dimensional grid. Its attributes are:\n\npoints::Matrix{Float64}: points[:,j] are the coordinates of point j.\nweights::Vector{Float64}: weights[j] is the mass of point j.\ngridshape::NTuple{D,Int}: shape of the grid, i.e. (length of x1, length of x2,...)\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiScaleOT.MultiScaleMeasure","page":"Internals","title":"MultiScaleOT.MultiScaleMeasure","text":"MultiScaleMeasure{<:AbstractMeasure}\n\nType encoding a measure at different resolutions, and how to refine a coarse version to a finer version. Inner representation is\n\nmutable struct MultiScaleMeasure{M<:AbstractMeasure{D} where D} \n    depth::Int # Number of resolutions\n    measures::Vector{M} # `measures[i]` gives resolution `i`\n    refinements::Vector{Vector{Vector{Int}}} # `refinements[i][j]` yields the indices of\n                                             # `mesures[i+1]` into which the atom\n                                             # `j` of `measures[i]` is splitted\nend\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultiScaleOT.MultiScaleMeasure-Union{Tuple{GridMeasure{D}}, Tuple{D}} where D","page":"Internals","title":"MultiScaleOT.MultiScaleMeasure","text":"MultiScaleMeasure(mu[; depth])\n\nCompute the MultiScaleMeasure with depth levels and finest  resolution given by mu.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.KL-Tuple{Real, Real}","page":"Internals","title":"MultiScaleOT.KL","text":"KL(a, b)\n\nComputes KL divergence between vectors a and b.  Yield Inf if a[i]>0, b[i]=0 for some i.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.PD_gap_dense-NTuple{9, Any}","page":"Internals","title":"MultiScaleOT.PD_gap_dense","text":"PD_gap_dense(a, b, P, c, X, Y, μ, ν, ε)\n\nCompute primal_score - dual_score using the dense versions of these functions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.PD_gap_sparse-NTuple{9, Any}","page":"Internals","title":"MultiScaleOT.PD_gap_sparse","text":"PD_gap_dense(a, b, P, c, X, Y, μ, ν, ε)\n\nCompute primal_score - dual_score using the dense versions of these functions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.compute_multiscale_depth-Tuple{Any}","page":"Internals","title":"MultiScaleOT.compute_multiscale_depth","text":"compute_multiscale_depth(mu::GridMeasure{D})\n\nCompute the minimum multiscale depth to refine a measure consisting of a single point to mu by dividing each point iteratively into (at most) 2^D points\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.constant_schedule-Tuple{Any, Int64}","page":"Internals","title":"MultiScaleOT.constant_schedule","text":"constant_schedule(value, N)\n\nRepeat value N times\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.dual_score_dense-NTuple{8, Any}","page":"Internals","title":"MultiScaleOT.dual_score_dense","text":"dual_score_dense(a, b, c, X, Y, μ, ν, ε)\n\nCompute the dual score of (a,b) for the entropic problem  with cost function c and regularization ε, using all points in the product space. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.dual_score_sparse-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, SparseArrays.SparseMatrixCSC}","page":"Internals","title":"MultiScaleOT.dual_score_sparse","text":"dual_score_sparse(a, b, c, X, Y, μ, ν, ε, P::SparseMatrixCSC)\n\nCompute the dual score of (a,b) for the entropic problem  with cost function c and regularization ε, using only the  indices (i,j) where P is non-zero. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.dual_score_sparse_eps0-NTuple{9, Any}","page":"Internals","title":"MultiScaleOT.dual_score_sparse_eps0","text":"dual_score_sparse_eps0(P, c, X, Y, μ, ν, ε, P; threshold = 1e-8)\n\nUnregularized dual cost. Yields infinite if some entry of the form  a[i]+b[j]-C[i,j] in the support of P is bigger than threshold.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.euclidean_barycenter-Tuple{Any, Any}","page":"Internals","title":"MultiScaleOT.euclidean_barycenter","text":"euclidean_barycenter(X, w)\n\nCompute the euclidean barycenter of the columns of X with weights w\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.fine_to_coarse-Union{Tuple{D}, Tuple{GridMeasure{D}, Any}} where D","page":"Internals","title":"MultiScaleOT.fine_to_coarse","text":"fine_to_coarse(mu::GridMeasure{D}, cellsize)\n\nCompute a coarse approximation of mu by combining  cellsize × ... × cellsize points together.  Return the coarser Measure new_mu and the partition cells, such that sum(mu.weights[cells[i]]) == new_mu.weights[i].\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.flat_grid-Union{Tuple{Vararg{Vector{T}, N} where N}, Tuple{T}} where T","page":"Internals","title":"MultiScaleOT.flat_grid","text":"flat_grid(xs...)\n\nCreate a grid with the arguments xs... and flatten its points to a matrix. Each column of the matrix represents one point on the grid,  and the first coordinate runs faster. \n\nExamples\n\njulia> x = [1, 2]; y = [2, 3];\njulia> flat_grid(x, y)\n\n2×4 Matrix{Int64}:\n 1  2  1  2\n 2  2  3  3\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_cells-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Any}, Tuple{Tuple{Vararg{Int64, N}}, Any, Any}} where N","page":"Internals","title":"MultiScaleOT.get_cells","text":"get_cells(shape, cellsize, offset=0)\n\nCall either get_cells_1D, get_cells_2D or get_cells_3D depending on the size of shape. Higher dimensional not implemented.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_cells_1D","page":"Internals","title":"MultiScaleOT.get_cells_1D","text":"get_cells_1D(N, cellsize, offset)\n\nDivide [1,...,N] into cells of size cellsize, with the first cell having offset indices. Return the list of cells and its shape. \n\nExamples\n\njulia> get_cells_1D(4, 2, 0)\n([[1, 2], [3, 4]], (2,))\n\njulia> get_cells_1D(4, 2, 1)\n([[1], [2, 3], [4]], (3,))\n\n\n\n\n\n","category":"function"},{"location":"internals/#MultiScaleOT.get_cells_2D-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.get_cells_2D","text":"get_cells_2D(shape, cellsize, offset)\n\nDivide [1,...,shape[1]]×[1,...,shape[2]] into cells of size (cellsize, cellsize), with the given offset. The order  of the basic cells is lexicographic, with the first index running faster.  Return the list of cells and its shape. \n\nExamples\n\njulia> get_cells_2D((4,4), 2, 0)\n([[1, 2, 5, 6], [3, 4, 7, 8], [9, 10, 13, 14], [11, 12, 15, 16]], (2, 2))\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_cells_3D-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.get_cells_3D","text":"get_cells_3D(shape, cellsize, offset)\n\nDivide [1,...,shape[1]]×[1,...,shape[2]]×[1,...,shape[3]] into cells of size (cellsize, cellsize, cellsize), with the given offset. The order  of the basic cells is lexicographic, with the first index running faster.  Return the list of cells and its shape. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_grid_nodes-Union{Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Tuple{Vararg{Int64, N}}}} where {T, N}","page":"Internals","title":"MultiScaleOT.get_grid_nodes","text":"get_grid_nodes(X, shapeX)\n\nFor X of size (N, prod(shapeX)) on a grid, get its 1-dimensional factors.\n\nExamples\n\njulia> X = [1 2 1 2 1 2\n            1 1 2 2 3 3];\njulia> get_grid_nodes(X, (2, 3))\n([1, 2], [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_kernel!-NTuple{6, Any}","page":"Internals","title":"MultiScaleOT.get_kernel!","text":"get_kernel!(C, a, b, μ, ν, ε)\n\nCompute inplace the Gibbs energy of matrix C, current duals a and b and scale it with marginals μ and ν.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_kernel-NTuple{6, Any}","page":"Internals","title":"MultiScaleOT.get_kernel","text":"get_kernel!(K, μ, ν, ε)\n\nCompute the Gibbs energy of matrix C, current duals a and b and scale it with marginals μ and ν.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_missing_dual_potential-NTuple{5, Any}","page":"Internals","title":"MultiScaleOT.get_missing_dual_potential","text":"get_missing_dual_potential(C, ϕ, ρ, ε, dim)\n\nCompute the conjugate potential of ϕ with regularization ε with marginal ρ. dim is the numeral of this potential. \n\nExamples\n\nIf (α, β) are the dual potentials for sinkhorn(C, μ, ν, ε), then α == get_missing_dual_potential(C, β, ν, ε, 1) and β == get_missing_dual_potential(C, α, μ, ε, 2).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_product_list-NTuple{5, Any}","page":"Internals","title":"MultiScaleOT.get_product_list","text":"get_product_list(it1, it2, it3, N1, N2)\n\nObtain the list of flattened indices of the cartesian indices (i,j,k), for k in it3, j in it2 and i in it1, assuming that the total dimension of the first and second axes are respectively N1 and N2. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_product_list-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.get_product_list","text":"get_product_list(it1, it2, N1)\n\nObtain the list of flattened indices of the cartesian indices (i,j), for j in it2 and i in it1, assuming that the total dimension of the first axis is N1.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.get_stabilized_kernel-Tuple{Function, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Internals","title":"MultiScaleOT.get_stabilized_kernel","text":"get_stabilized_kernel(c::Function, a, b, ε, X, Y, μ, ν, θ[, colptr0, roval0])\n\nCompute a truncated, stabilized kernel, following Section 3.3 of https://arxiv.org/abs/1610.06519, using the dual variables (a, b), the threshold θ and a previous estimate on the neighborhood given by (colptr0, rowval0). These must be interpreted as the representation of a CSC sparse matrix, on a subset of whose entries the truncated kernel will lie.\n\nIf colptr0, rowval0 are not given, it is assumed that the all entries must be inspected.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.isthere_nan_or_inf-Tuple{Any}","page":"Internals","title":"MultiScaleOT.isthere_nan_or_inf","text":"isthere_nan_or_inf(v)\n\nCheck if there is NaN or Inf in iterable v\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.l1-Tuple{Any, Any}","page":"Internals","title":"MultiScaleOT.l1","text":"l1(a, b)\n\nCompute ℓ^1 distance between a and b. Does not allocate. If the sizes of the vectors are known with certainty, l1_inbounds might be preferred.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.l1_inbounds-Tuple{Any, Any}","page":"Internals","title":"MultiScaleOT.l1_inbounds","text":"l1_inbounds(a, b)\n\nCompute ℓ^1 distance between a and b. Does not allocate nor perform bound checks on the vectors\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.log_sinkhorn!-NTuple{6, Any}","page":"Internals","title":"MultiScaleOT.log_sinkhorn!","text":"log_sinkhorn!(a, b, μ, ν, C, ε; kwargs...)\n\nRun a log-stabilized implementation of the Sinkhorn algorithm on potentials a and b (first iteration updates a), with marginals mu and nu, cost matrix C and regularization  strength ε, until some maximum error or number of  iterations is achieved. \n\nOptional arguments are: \n\nmax_iter: Maximum number of iterations. \nmax_error: Desired error. \nmax_error_rel: Whether the max_error is relative to  the mass of μ.\nverbose: Whether convergence updates are desired. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.log_sinkhorn!-NTuple{9, Any}","page":"Internals","title":"MultiScaleOT.log_sinkhorn!","text":"log_sinkhorn!(a, b, μ, ν, Ka, Kb, K, Niter)\n\nRun a log-stabilized implementation of the Sinkhorn algorithm  for Niter iterations. Mutate its arguments.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.logsumexp!-Tuple{Any, Matrix{T} where T, Any, Any, Any}","page":"Internals","title":"MultiScaleOT.logsumexp!","text":"logsumexp!(y, A, b, ε, dims)\n\nCompute the softmin of A - b with regularization ε along the dims dimension, where b is subtracted also along the dims dimension. Modify the array y.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.logsumexp-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.logsumexp","text":"logsumexp(x, b, ε)\n\nCompute the softmin of x-b with regularization ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.logsumexp-Tuple{Any, Any}","page":"Internals","title":"MultiScaleOT.logsumexp","text":"logsumexp(x, ε)\n\nCompute the softmin of x with regularization ε.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.logsumexp-Tuple{Matrix{T} where T, Any, Any, Any}","page":"Internals","title":"MultiScaleOT.logsumexp","text":"logsumexp(A, b, ε, dims)\n\nCompute the softmin of A - b with regularization ε along the dims dimension, where b is subtracted also along the dims dimension.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.logsumexp-Tuple{Matrix{T} where T, Any, Any}","page":"Internals","title":"MultiScaleOT.logsumexp","text":"logsumexp(A, ε, dims)\n\nCompute the softmin of A with regularization ε along the dims dimension.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.lp-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.lp","text":"lp(a, b, p)\n\nCompute the ℓ^p distance between a and b. Does not allocate. If the sizes of the vectors are known with certainty, lp_inbounds might be preferred.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.lp_inbounds-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.lp_inbounds","text":"lp_inbounds(a, b, p)\n\nCompute the ℓ^p distance between a and b. Does not allocate nor perform bounds checks on the vectors\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.lpp-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.lpp","text":"lpp(a, b, p)\n\nCompute the p-th power of the ℓ^p distance between a and b. Does not allocate. If the sizes of the vectors are known with certainty, lpp_inbounds might be preferred.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.lpp_inbounds-Tuple{Any, Any, Any}","page":"Internals","title":"MultiScaleOT.lpp_inbounds","text":"lpp_inbounds(a, b, p)\n\nCompute p-th power of the ℓ^p distance between a and b. Does not allocate nor perform bounds checks on the vectors\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.make_schedule-Tuple{}","page":"Internals","title":"MultiScaleOT.make_schedule","text":"make_schedule(; nt...)\n\nGenerate a StructArray` representing a schedule, this is, columns represent the values a parameter, is taking on each step of the algorithm; conversely, rows represent the set of parameters to be used at a given stage of the algorithm.\n\nThe elements in nt are arrays of singletons. In the later case they are repeated to match the length of the array ones.\n\nExamples\n\njulia> sinkhornschedule = makeschedule(                 ε = [4,  2,  2,  1],                  N = [64, 64, 32, 32],                 θ = 1e-20,                 max_error = 1e-6         )\n\n4-element StructArray(::Vector{Int64}, ::Vector{Int64}, ::Vector{Float64}, ::Vector{Float64}) with eltype NamedTuple{(:ε, :N, :θ, :maxerror), Tuple{Int64, Int64, Float64, Float64}}: (ε = 4, N = 64, θ = 1.0e-20, maxerror = 1.0e-6) (ε = 2, N = 64, θ = 1.0e-20, maxerror = 1.0e-6) (ε = 2, N = 32, θ = 1.0e-20, maxerror = 1.0e-6) (ε = 1, N = 32, θ = 1.0e-20, max_error = 1.0e-6)\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.mean-Tuple{Any, Any}","page":"Internals","title":"MultiScaleOT.mean","text":"mean(x, J)\n\nMean of x[J], non-allocating\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.normalize!","page":"Internals","title":"MultiScaleOT.normalize!","text":"normalize!(a[, mass = 1])\n\nNormalize the vector a so that it adds up to mass. Does not perform any check on the positivity of a.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MultiScaleOT.pad_extrapolate-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Internals","title":"MultiScaleOT.pad_extrapolate","text":"pad_extrapolate(x::AbstractVector{T})\n\nExtrapolate a vector of length N at both ends.  The result is a vector of length N+2. \n\nExamples\n\njulia> pad_extrapolate([1,2,3])\n5-element Vector{Int64}:\n 0\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.pad_extrapolate-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Internals","title":"MultiScaleOT.pad_extrapolate","text":"pad_extrapolate(A::Matrix)\n\nExtrapolate a (N,M) matrix along its boundary. The result is a  (N+2, M+2) matrix. \n\nExamples\n\njulia> pad_extrapolate([1 2; 3 4])\n4×4 Matrix{Float64}:\n -2.0  -1.0  0.0  1.0\n  0.0   1.0  2.0  3.0\n  2.0   3.0  4.0  5.0\n  4.0   5.0  6.0  7.0\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.primal_score_dense-NTuple{7, Any}","page":"Internals","title":"MultiScaleOT.primal_score_dense","text":"primal_score_dense(P, c, X, Y, μ, ν, ε)\n\nCompute the primal score of P for the entropic problem  with cost function c and regularization ε, using all entries of P. Works for P both dense and sparse.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.primal_score_sparse-NTuple{7, Any}","page":"Internals","title":"MultiScaleOT.primal_score_sparse","text":"primal_score_sparse(P::SparseMatrixCSC, c, X, Y, μ, ν, ε)\n\nCompute the primal score of P for the entropic problem  with cost function c and regularization ε, using only the stored entries of P.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.primal_score_sparse_eps0-NTuple{7, Any}","page":"Internals","title":"MultiScaleOT.primal_score_sparse_eps0","text":"primal_score_sparse_eps0(P, c, X, Y, μ, ν, ε)\n\nUnregularized primal cost. To be called by primal_score_sparse\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.refine_support-NTuple{8, Any}","page":"Internals","title":"MultiScaleOT.refine_support","text":"refine_support(colptr0, rowval0, refinementX, refinementY)\n\nSeeing colptr0, rowval0 as the support of a sparse matrix K0,  obtain a new support colptr, rowval that is the support of the matrix K resulting from the refinements refinementX, refinementY\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.scaling_schedule-Union{Tuple{T}, Tuple{Int64, T, Int64, T}} where T","page":"Internals","title":"MultiScaleOT.scaling_schedule","text":"scaling_schedule(depth, target_value, Nsteps, factor; last_iter = [])\n\nGenerate the vector\n\ntarget_value.* [factor^(depth*(Nsteps-1)), \n                factor^(depth*(Nsteps-1)-1),\n                factor^(depth*(Nsteps-1)-2),\n                ...\n                factor^((depth-1)*(Nsteps-1)),\n                factor^((depth-1)*(Nsteps-1)),\n                factor^((depth-1)*(Nsteps-1)-1),\n                ...\n                factor^((depth-2)*(Nsteps-1)),\n                factor^((depth-2)*(Nsteps-1)),\n                ...\n                ...\n                1\n                ;\n                last_iter]\n\nUseful for generating scaling schedules for the regularization ε.\n\nExamples\n\njulia> eps_target = 1.; factor = 2.; Nsteps = 3;\njulia> eps_schedule = scaling_schedule(depth, eps_target, Nsteps, factor)\n9-element Vector{Float64}:\n 64.0\n 32.0\n 16.0\n 16.0\n  8.0\n  4.0\n  4.0\n  2.0\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.sinkhorn!-NTuple{7, Any}","page":"Internals","title":"MultiScaleOT.sinkhorn!","text":"sinkhorn!(u, v, μ, ν, K, KT, Niter)\n\nRun Niter iterations of the Sinkhorn algorithm inplace on the scaling factors (u,v), with marginals μ and ν and Gibbs entropy given by  K and its transpose KT. At the end of the iterates the coupling u.*K.*v'has exact first marginal,  i.e.,sum(u .* K .* v', dims = 2)[:] == μ`.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.sinkhorn_stabilized!-NTuple{6, Any}","page":"Internals","title":"MultiScaleOT.sinkhorn_stabilized!","text":"sinkhorn_stabilized!(a, b, μ, ν, K, ε; kwargs...)\n\nImplement the stabilized Sinkhorn algorithm of https://arxiv.org/abs/1610.06519.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.template_schedule-Union{Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}}} where T","page":"Internals","title":"MultiScaleOT.template_schedule","text":"template_schedule(depth, template, factors; last_iter = [])\n\nGenerate the vector [factors[1].*template; ... ; factors[depth].*template; last_iter] Useful to define a schedule with a certain substructure.  When factors is a singleton, it is transformed into fill(factors, depth). When template is an Int, it is transformed into ones(template).\n\nExamples\n\njulia> depth = 3; Ns = [1, 2, 4]; Nsteps = 2;\njulia> template_schedule(depth, Nsteps, Ns)\n6-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 4\n 4\n\njulia> depth = 3; maxiters_template = [2000, 1000]; factor = 1;\njulia> template_schedule(depth, maxiters_template, factor)\n6-element Vector{Int64}:\n 2000\n 1000\n 2000\n 1000\n 2000\n 1000\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.update_current_Y_marginal!-NTuple{5, Any}","page":"Internals","title":"MultiScaleOT.update_current_Y_marginal!","text":"update_current_Y_marginal!(νK, v, KT, u, ν)\n\nUpdate the current Y marginal of the coupling and  return the error with respect to the true marginal ν.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultiScaleOT.DEFAULT_PARAMETERS","page":"Internals","title":"MultiScaleOT.DEFAULT_PARAMETERS","text":"DEFAULT_PARAMETERS\n\nDefault parameters for the multiscale routines\n\n\n\n\n\n","category":"constant"}]
}
