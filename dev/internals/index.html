<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · MultiScaleOT.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-136089579-2"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-136089579-2', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ismedina.github.io/MultiScaleOT.jl/internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultiScaleOT.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../library/">Library</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="github.com/ismedina/MultiScaleOT.jl.git" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.AbstractMeasure" href="#MultiScaleOT.AbstractMeasure"><code>MultiScaleOT.AbstractMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMeasure{D}</code></pre><p>Type from which <code>GridMeasure{D}, CloudMeasure{D}</code> inherit.  It is left unexported to avoid potential conflicts with  <code>MeasureTheory.jl</code>, which has another type with the same name.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.CloudMeasure" href="#MultiScaleOT.CloudMeasure"><code>MultiScaleOT.CloudMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CloudMeasure{D} &lt;: AbstractMeasure{D}</code></pre><p>A measure supported on an unstructured <code>D</code>-dimensional point cloud. Its attributes are:</p><ul><li><code>points::Matrix{Float64}</code>: <code>points[:,j]</code> are the coordinates of point <code>j</code>.</li><li><code>weights::Vector{Float64}</code>: <code>weights[j]</code> is the mass of point <code>j</code>.</li><li><code>extent::NTuple{D, Tuple{Float64, Float64}}</code>: <code>extent[i]</code> are lower and upper bounds   on the <code>i</code>-th row of <code>points</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.GridMeasure" href="#MultiScaleOT.GridMeasure"><code>MultiScaleOT.GridMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridMeasure{D} &lt;: AbstractMeasure{D}</code></pre><p>A measure supported on a <code>D</code>-dimensional grid. Its attributes are:</p><ul><li><code>points::Matrix{Float64}</code>: <code>points[:,j]</code> are the coordinates of point <code>j</code>.</li><li><code>weights::Vector{Float64}</code>: <code>weights[j]</code> is the mass of point <code>j</code>.</li><li><code>gridshape::NTuple{D,Int}</code>: shape of the grid, i.e. (length of x1, length of x2,...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.MultiScaleMeasure" href="#MultiScaleOT.MultiScaleMeasure"><code>MultiScaleOT.MultiScaleMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiScaleMeasure{&lt;:AbstractMeasure}</code></pre><p>Type encoding a measure at different resolutions, and how to refine a coarse version to a finer version. Inner representation is</p><pre><code class="language-julia hljs">mutable struct MultiScaleMeasure{M&lt;:AbstractMeasure{D} where D} 
    depth::Int # Number of resolutions
    measures::Vector{M} # `measures[i]` gives resolution `i`
    refinements::Vector{Vector{Vector{Int}}} # `refinements[i][j]` yields the indices of
                                             # `mesures[i+1]` into which the atom
                                             # `j` of `measures[i]` is splitted
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.MultiScaleMeasure-Union{Tuple{GridMeasure{D}}, Tuple{D}} where D" href="#MultiScaleOT.MultiScaleMeasure-Union{Tuple{GridMeasure{D}}, Tuple{D}} where D"><code>MultiScaleOT.MultiScaleMeasure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultiScaleMeasure(mu[; depth])</code></pre><p>Compute the MultiScaleMeasure with <code>depth</code> levels and finest  resolution given by <code>mu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.KL-Tuple{Real, Real}" href="#MultiScaleOT.KL-Tuple{Real, Real}"><code>MultiScaleOT.KL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KL(a, b)</code></pre><p>Computes KL divergence between vectors <code>a</code> and <code>b</code>.  Yield <code>Inf</code> if <code>a[i]&gt;0, b[i]=0</code> for some <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.PD_gap_dense-NTuple{9, Any}" href="#MultiScaleOT.PD_gap_dense-NTuple{9, Any}"><code>MultiScaleOT.PD_gap_dense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PD_gap_dense(a, b, P, c, X, Y, μ, ν, ε)</code></pre><p>Compute <code>primal_score - dual_score</code> using the dense versions of these functions.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.PD_gap_sparse-NTuple{9, Any}" href="#MultiScaleOT.PD_gap_sparse-NTuple{9, Any}"><code>MultiScaleOT.PD_gap_sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PD_gap_dense(a, b, P, c, X, Y, μ, ν, ε)</code></pre><p>Compute <code>primal_score - dual_score</code> using the dense versions of these functions.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.compute_multiscale_depth-Tuple{Any}" href="#MultiScaleOT.compute_multiscale_depth-Tuple{Any}"><code>MultiScaleOT.compute_multiscale_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_multiscale_depth(mu::GridMeasure{D})</code></pre><p>Compute the minimum multiscale depth to refine a measure consisting of a single point to <code>mu</code> by dividing each point iteratively into (at most) 2^D points</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.constant_schedule-Tuple{Any, Int64}" href="#MultiScaleOT.constant_schedule-Tuple{Any, Int64}"><code>MultiScaleOT.constant_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant_schedule(value, N)</code></pre><p>Repeat <code>value</code> <code>N</code> times</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.dual_score_dense-NTuple{8, Any}" href="#MultiScaleOT.dual_score_dense-NTuple{8, Any}"><code>MultiScaleOT.dual_score_dense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_score_dense(a, b, c, X, Y, μ, ν, ε)</code></pre><p>Compute the dual score of <code>(a,b)</code> for the entropic problem  with cost function <code>c</code> and regularization <code>ε</code>, using all points in the product space. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.dual_score_sparse-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, SparseArrays.SparseMatrixCSC}" href="#MultiScaleOT.dual_score_sparse-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, SparseArrays.SparseMatrixCSC}"><code>MultiScaleOT.dual_score_sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_score_sparse(a, b, c, X, Y, μ, ν, ε, P::SparseMatrixCSC)</code></pre><p>Compute the dual score of <code>(a,b)</code> for the entropic problem  with cost function <code>c</code> and regularization <code>ε</code>, using only the  indices <code>(i,j)</code> where <code>P</code> is non-zero. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.dual_score_sparse_eps0-NTuple{9, Any}" href="#MultiScaleOT.dual_score_sparse_eps0-NTuple{9, Any}"><code>MultiScaleOT.dual_score_sparse_eps0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_score_sparse_eps0(P, c, X, Y, μ, ν, ε, P; threshold = 1e-8)</code></pre><p>Unregularized dual cost. Yields infinite if some entry of the form  <code>a[i]+b[j]-C[i,j]</code> in the support of <code>P</code> is bigger than <code>threshold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.euclidean_barycenter-Tuple{Any, Any}" href="#MultiScaleOT.euclidean_barycenter-Tuple{Any, Any}"><code>MultiScaleOT.euclidean_barycenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">euclidean_barycenter(X, w)</code></pre><p>Compute the euclidean barycenter of the columns of <code>X</code> with weights <code>w</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.fine_to_coarse-Union{Tuple{D}, Tuple{GridMeasure{D}, Any}} where D" href="#MultiScaleOT.fine_to_coarse-Union{Tuple{D}, Tuple{GridMeasure{D}, Any}} where D"><code>MultiScaleOT.fine_to_coarse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fine_to_coarse(mu::GridMeasure{D}, cellsize)</code></pre><p>Compute a coarse approximation of <code>mu</code> by combining  <code>cellsize × ... × cellsize</code> points together.  Return the coarser Measure <code>new_mu</code> and the partition <code>cells</code>, such that <code>sum(mu.weights[cells[i]]) == new_mu.weights[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.flat_grid-Union{Tuple{Vararg{Vector{T}, N} where N}, Tuple{T}} where T" href="#MultiScaleOT.flat_grid-Union{Tuple{Vararg{Vector{T}, N} where N}, Tuple{T}} where T"><code>MultiScaleOT.flat_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flat_grid(xs...)</code></pre><p>Create a grid with the arguments <code>xs...</code> and flatten its points to a matrix. Each column of the matrix represents one point on the grid,  and the first coordinate runs faster. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1, 2]; y = [2, 3];
julia&gt; flat_grid(x, y)

2×4 Matrix{Int64}:
 1  2  1  2
 2  2  3  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_cells-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Any}, Tuple{Tuple{Vararg{Int64, N}}, Any, Any}} where N" href="#MultiScaleOT.get_cells-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Any}, Tuple{Tuple{Vararg{Int64, N}}, Any, Any}} where N"><code>MultiScaleOT.get_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cells(shape, cellsize, offset=0)</code></pre><p>Call either <code>get_cells_1D</code>, <code>get_cells_2D</code> or <code>get_cells_3D</code> depending on the size of <code>shape</code>. Higher dimensional not implemented.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_cells_1D" href="#MultiScaleOT.get_cells_1D"><code>MultiScaleOT.get_cells_1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cells_1D(N, cellsize, offset)</code></pre><p>Divide <code>[1,...,N]</code> into cells of size <code>cellsize</code>, with the first cell having <code>offset</code> indices. Return the list of cells and its shape. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_cells_1D(4, 2, 0)
([[1, 2], [3, 4]], (2,))

julia&gt; get_cells_1D(4, 2, 1)
([[1], [2, 3], [4]], (3,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_cells_2D-Tuple{Any, Any, Any}" href="#MultiScaleOT.get_cells_2D-Tuple{Any, Any, Any}"><code>MultiScaleOT.get_cells_2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cells_2D(shape, cellsize, offset)</code></pre><p>Divide <code>[1,...,shape[1]]×[1,...,shape[2]]</code> into cells of size <code>(cellsize, cellsize)</code>, with the given <code>offset</code>. The order  of the basic cells is lexicographic, with the first index running faster.  Return the list of cells and its shape. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; get_cells_2D((4,4), 2, 0)
([[1, 2, 5, 6], [3, 4, 7, 8], [9, 10, 13, 14], [11, 12, 15, 16]], (2, 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_cells_3D-Tuple{Any, Any, Any}" href="#MultiScaleOT.get_cells_3D-Tuple{Any, Any, Any}"><code>MultiScaleOT.get_cells_3D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cells_3D(shape, cellsize, offset)</code></pre><p>Divide <code>[1,...,shape[1]]×[1,...,shape[2]]×[1,...,shape[3]]</code> into cells of size <code>(cellsize, cellsize, cellsize)</code>, with the given <code>offset</code>. The order  of the basic cells is lexicographic, with the first index running faster.  Return the list of cells and its shape. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_grid_nodes-Union{Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Tuple{Vararg{Int64, N}}}} where {T, N}" href="#MultiScaleOT.get_grid_nodes-Union{Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>MultiScaleOT.get_grid_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_grid_nodes(X, shapeX)</code></pre><p>For <code>X</code> of size <code>(N, prod(shapeX))</code> on a grid, get its 1-dimensional factors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = [1 2 1 2 1 2
            1 1 2 2 3 3];
julia&gt; get_grid_nodes(X, (2, 3))
([1, 2], [1, 2, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_kernel!-NTuple{6, Any}" href="#MultiScaleOT.get_kernel!-NTuple{6, Any}"><code>MultiScaleOT.get_kernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kernel!(C, a, b, μ, ν, ε)</code></pre><p>Compute inplace the Gibbs energy of matrix <code>C</code>, current duals <code>a</code> and <code>b</code> and scale it with marginals <code>μ</code> and <code>ν</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_kernel-NTuple{6, Any}" href="#MultiScaleOT.get_kernel-NTuple{6, Any}"><code>MultiScaleOT.get_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kernel!(K, μ, ν, ε)</code></pre><p>Compute the Gibbs energy of matrix <code>C</code>, current duals <code>a</code> and <code>b</code> and scale it with marginals <code>μ</code> and <code>ν</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_missing_dual_potential-NTuple{5, Any}" href="#MultiScaleOT.get_missing_dual_potential-NTuple{5, Any}"><code>MultiScaleOT.get_missing_dual_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_missing_dual_potential(C, ϕ, ρ, ε, dim)</code></pre><p>Compute the conjugate potential of ϕ with regularization ε with marginal ρ. <code>dim</code> is the numeral of this potential. </p><p><strong>Examples</strong></p><p>If (α, β) are the dual potentials for <code>sinkhorn(C, μ, ν, ε)</code>, then <code>α == get_missing_dual_potential(C, β, ν, ε, 1)</code> and <code>β == get_missing_dual_potential(C, α, μ, ε, 2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_product_list-NTuple{5, Any}" href="#MultiScaleOT.get_product_list-NTuple{5, Any}"><code>MultiScaleOT.get_product_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_product_list(it1, it2, it3, N1, N2)</code></pre><p>Obtain the list of flattened indices of the cartesian indices <code>(i,j,k)</code>, for <code>k</code> in <code>it3</code>, <code>j</code> in <code>it2</code> and <code>i</code> in <code>it1</code>, assuming that the total dimension of the first and second axes are respectively <code>N1</code> and <code>N2</code>. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_product_list-Tuple{Any, Any, Any}" href="#MultiScaleOT.get_product_list-Tuple{Any, Any, Any}"><code>MultiScaleOT.get_product_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_product_list(it1, it2, N1)</code></pre><p>Obtain the list of flattened indices of the cartesian indices <code>(i,j)</code>, for <code>j</code> in <code>it2</code> and <code>i</code> in <code>it1</code>, assuming that the total dimension of the first axis is <code>N1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.get_stabilized_kernel-Tuple{Function, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#MultiScaleOT.get_stabilized_kernel-Tuple{Function, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>MultiScaleOT.get_stabilized_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_stabilized_kernel(c::Function, a, b, ε, X, Y, μ, ν, θ[, colptr0, roval0])</code></pre><p>Compute a truncated, stabilized kernel, following Section 3.3 of https://arxiv.org/abs/1610.06519, using the dual variables <code>(a, b)</code>, the threshold <code>θ</code> and a previous estimate on the neighborhood given by <code>(colptr0, rowval0)</code>. These must be interpreted as the representation of a CSC sparse matrix, on a subset of whose entries the truncated kernel will lie.</p><p>If <code>colptr0, rowval0</code> are not given, it is assumed that the all entries must be inspected.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.isthere_nan_or_inf-Tuple{Any}" href="#MultiScaleOT.isthere_nan_or_inf-Tuple{Any}"><code>MultiScaleOT.isthere_nan_or_inf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isthere_nan_or_inf(v)</code></pre><p>Check if there is <code>NaN</code> or <code>Inf</code> in iterable <code>v</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.l1-Tuple{Any, Any}" href="#MultiScaleOT.l1-Tuple{Any, Any}"><code>MultiScaleOT.l1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">l1(a, b)</code></pre><p>Compute ℓ^1 distance between <code>a</code> and <code>b</code>. Does not allocate. If the sizes of the vectors are known with certainty, <code>l1_inbounds</code> might be preferred.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.l1_inbounds-Tuple{Any, Any}" href="#MultiScaleOT.l1_inbounds-Tuple{Any, Any}"><code>MultiScaleOT.l1_inbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">l1_inbounds(a, b)</code></pre><p>Compute ℓ^1 distance between <code>a</code> and <code>b</code>. Does not allocate nor perform bound checks on the vectors</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.log_sinkhorn!-NTuple{6, Any}" href="#MultiScaleOT.log_sinkhorn!-NTuple{6, Any}"><code>MultiScaleOT.log_sinkhorn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_sinkhorn!(a, b, μ, ν, C, ε; kwargs...)</code></pre><p>Run a log-stabilized implementation of the Sinkhorn algorithm on potentials <code>a</code> and <code>b</code> (first iteration updates <code>a</code>), with marginals <code>mu</code> and <code>nu</code>, cost matrix <code>C</code> and regularization  strength <code>ε</code>, until some maximum error or number of  iterations is achieved. </p><p>Optional arguments are: </p><ul><li><code>max_iter</code>: Maximum number of iterations. </li><li><code>max_error</code>: Desired error. </li><li><code>max_error_rel</code>: Whether the <code>max_error</code> is relative to  the mass of <code>μ</code>.</li><li><code>verbose</code>: Whether convergence updates are desired. </li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.log_sinkhorn!-NTuple{9, Any}" href="#MultiScaleOT.log_sinkhorn!-NTuple{9, Any}"><code>MultiScaleOT.log_sinkhorn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_sinkhorn!(a, b, μ, ν, Ka, Kb, K, Niter)</code></pre><p>Run a log-stabilized implementation of the Sinkhorn algorithm  for <code>Niter</code> iterations. Mutate its arguments.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.logsumexp!-Tuple{Any, Matrix{T} where T, Any, Any, Any}" href="#MultiScaleOT.logsumexp!-Tuple{Any, Matrix{T} where T, Any, Any, Any}"><code>MultiScaleOT.logsumexp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logsumexp!(y, A, b, ε, dims)</code></pre><p>Compute the softmin of <code>A - b</code> with regularization <code>ε</code> along the <code>dims</code> dimension, where <code>b</code> is subtracted also along the <code>dims</code> dimension. Modify the array <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.logsumexp-Tuple{Any, Any, Any}" href="#MultiScaleOT.logsumexp-Tuple{Any, Any, Any}"><code>MultiScaleOT.logsumexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logsumexp(x, b, ε)</code></pre><p>Compute the softmin of <code>x-b</code> with regularization <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.logsumexp-Tuple{Any, Any}" href="#MultiScaleOT.logsumexp-Tuple{Any, Any}"><code>MultiScaleOT.logsumexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logsumexp(x, ε)</code></pre><p>Compute the softmin of <code>x</code> with regularization <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.logsumexp-Tuple{Matrix{T} where T, Any, Any, Any}" href="#MultiScaleOT.logsumexp-Tuple{Matrix{T} where T, Any, Any, Any}"><code>MultiScaleOT.logsumexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logsumexp(A, b, ε, dims)</code></pre><p>Compute the softmin of <code>A - b</code> with regularization <code>ε</code> along the <code>dims</code> dimension, where <code>b</code> is subtracted also along the <code>dims</code> dimension.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.logsumexp-Tuple{Matrix{T} where T, Any, Any}" href="#MultiScaleOT.logsumexp-Tuple{Matrix{T} where T, Any, Any}"><code>MultiScaleOT.logsumexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logsumexp(A, ε, dims)</code></pre><p>Compute the softmin of <code>A</code> with regularization <code>ε</code> along the <code>dims</code> dimension.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.lp-Tuple{Any, Any, Any}" href="#MultiScaleOT.lp-Tuple{Any, Any, Any}"><code>MultiScaleOT.lp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lp(a, b, p)</code></pre><p>Compute the ℓ^p distance between <code>a</code> and <code>b</code>. Does not allocate. If the sizes of the vectors are known with certainty, <code>lp_inbounds</code> might be preferred.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.lp_inbounds-Tuple{Any, Any, Any}" href="#MultiScaleOT.lp_inbounds-Tuple{Any, Any, Any}"><code>MultiScaleOT.lp_inbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lp_inbounds(a, b, p)</code></pre><p>Compute the ℓ^p distance between <code>a</code> and <code>b</code>. Does not allocate nor perform bounds checks on the vectors</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.lpp-Tuple{Any, Any, Any}" href="#MultiScaleOT.lpp-Tuple{Any, Any, Any}"><code>MultiScaleOT.lpp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lpp(a, b, p)</code></pre><p>Compute the p-th power of the ℓ^p distance between <code>a</code> and <code>b</code>. Does not allocate. If the sizes of the vectors are known with certainty, <code>lpp_inbounds</code> might be preferred.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.lpp_inbounds-Tuple{Any, Any, Any}" href="#MultiScaleOT.lpp_inbounds-Tuple{Any, Any, Any}"><code>MultiScaleOT.lpp_inbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lpp_inbounds(a, b, p)</code></pre><p>Compute p-th power of the ℓ^p distance between <code>a</code> and <code>b</code>. Does not allocate nor perform bounds checks on the vectors</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.make_schedule-Tuple{}" href="#MultiScaleOT.make_schedule-Tuple{}"><code>MultiScaleOT.make_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_schedule(; nt...)</code></pre><p>Generate a <code>StructArray</code>` representing a schedule, this is, columns represent the values a parameter, is taking on each step of the algorithm; conversely, rows represent the set of parameters to be used at a given stage of the algorithm.</p><p>The elements in <code>nt</code> are arrays of singletons. In the later case they are repeated to match the length of the array ones.</p><p><strong>Examples</strong></p><p>julia&gt; sinkhorn<em>schedule = make</em>schedule(                 ε = [4,  2,  2,  1],                  N = [64, 64, 32, 32],                 θ = 1e-20,                 max_error = 1e-6         )</p><p>4-element StructArray(::Vector{Int64}, ::Vector{Int64}, ::Vector{Float64}, ::Vector{Float64}) with eltype NamedTuple{(:ε, :N, :θ, :max<em>error), Tuple{Int64, Int64, Float64, Float64}}: (ε = 4, N = 64, θ = 1.0e-20, max</em>error = 1.0e-6) (ε = 2, N = 64, θ = 1.0e-20, max<em>error = 1.0e-6) (ε = 2, N = 32, θ = 1.0e-20, max</em>error = 1.0e-6) (ε = 1, N = 32, θ = 1.0e-20, max_error = 1.0e-6)</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.mean-Tuple{Any, Any}" href="#MultiScaleOT.mean-Tuple{Any, Any}"><code>MultiScaleOT.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(x, J)</code></pre><p>Mean of <code>x[J]</code>, non-allocating</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.normalize!" href="#MultiScaleOT.normalize!"><code>MultiScaleOT.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize!(a[, mass = 1])</code></pre><p>Normalize the vector <code>a</code> so that it adds up to <code>mass</code>. Does not perform any check on the positivity of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.pad_extrapolate-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#MultiScaleOT.pad_extrapolate-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>MultiScaleOT.pad_extrapolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pad_extrapolate(x::AbstractVector{T})</code></pre><p>Extrapolate a vector of length <code>N</code> at both ends.  The result is a vector of length <code>N+2</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pad_extrapolate([1,2,3])
5-element Vector{Int64}:
 0
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.pad_extrapolate-Union{Tuple{Matrix{T}}, Tuple{T}} where T" href="#MultiScaleOT.pad_extrapolate-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>MultiScaleOT.pad_extrapolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pad_extrapolate(A::Matrix)</code></pre><p>Extrapolate a <code>(N,M)</code> matrix along its boundary. The result is a  <code>(N+2, M+2)</code> matrix. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pad_extrapolate([1 2; 3 4])
4×4 Matrix{Float64}:
 -2.0  -1.0  0.0  1.0
  0.0   1.0  2.0  3.0
  2.0   3.0  4.0  5.0
  4.0   5.0  6.0  7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.primal_score_dense-NTuple{7, Any}" href="#MultiScaleOT.primal_score_dense-NTuple{7, Any}"><code>MultiScaleOT.primal_score_dense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primal_score_dense(P, c, X, Y, μ, ν, ε)</code></pre><p>Compute the primal score of <code>P</code> for the entropic problem  with cost function <code>c</code> and regularization <code>ε</code>, using all entries of <code>P</code>. Works for <code>P</code> both dense and sparse.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.primal_score_sparse-NTuple{7, Any}" href="#MultiScaleOT.primal_score_sparse-NTuple{7, Any}"><code>MultiScaleOT.primal_score_sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primal_score_sparse(P::SparseMatrixCSC, c, X, Y, μ, ν, ε)</code></pre><p>Compute the primal score of <code>P</code> for the entropic problem  with cost function <code>c</code> and regularization <code>ε</code>, using only the stored entries of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.primal_score_sparse_eps0-NTuple{7, Any}" href="#MultiScaleOT.primal_score_sparse_eps0-NTuple{7, Any}"><code>MultiScaleOT.primal_score_sparse_eps0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primal_score_sparse_eps0(P, c, X, Y, μ, ν, ε)</code></pre><p>Unregularized primal cost. To be called by <code>primal_score_sparse</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.refine_support-NTuple{8, Any}" href="#MultiScaleOT.refine_support-NTuple{8, Any}"><code>MultiScaleOT.refine_support</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_support(colptr0, rowval0, refinementX, refinementY)</code></pre><p>Seeing <code>colptr0, rowval0</code> as the support of a sparse matrix <code>K0</code>,  obtain a new support <code>colptr, rowval</code> that is the support of the matrix <code>K</code> resulting from the refinements <code>refinementX, refinementY</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.scaling_schedule-Union{Tuple{T}, Tuple{Int64, T, Int64, T}} where T" href="#MultiScaleOT.scaling_schedule-Union{Tuple{T}, Tuple{Int64, T, Int64, T}} where T"><code>MultiScaleOT.scaling_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaling_schedule(depth, target_value, Nsteps, factor; last_iter = [])</code></pre><p>Generate the vector</p><pre><code class="language-julia hljs">target_value.* [factor^(depth*(Nsteps-1)), 
                factor^(depth*(Nsteps-1)-1),
                factor^(depth*(Nsteps-1)-2),
                ...
                factor^((depth-1)*(Nsteps-1)),
                factor^((depth-1)*(Nsteps-1)),
                factor^((depth-1)*(Nsteps-1)-1),
                ...
                factor^((depth-2)*(Nsteps-1)),
                factor^((depth-2)*(Nsteps-1)),
                ...
                ...
                1
                ;
                last_iter]</code></pre><p>Useful for generating scaling schedules for the regularization <code>ε</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; eps_target = 1.; factor = 2.; Nsteps = 3;
julia&gt; eps_schedule = scaling_schedule(depth, eps_target, Nsteps, factor)
9-element Vector{Float64}:
 64.0
 32.0
 16.0
 16.0
  8.0
  4.0
  4.0
  2.0
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.sinkhorn!-NTuple{7, Any}" href="#MultiScaleOT.sinkhorn!-NTuple{7, Any}"><code>MultiScaleOT.sinkhorn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sinkhorn!(u, v, μ, ν, K, KT, Niter)</code></pre><p>Run <code>Niter</code> iterations of the Sinkhorn algorithm inplace on the scaling factors <code>(u,v)</code>, with marginals <code>μ</code> and <code>ν</code> and Gibbs entropy given by  <code>K</code> and its transpose <code>KT</code>. At the end of the iterates the coupling <code>u.*K.*v&#39;</code><code>has exact first marginal,  i.e.,</code>sum(u .* K .* v&#39;, dims = 2)[:] == μ`.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.sinkhorn_stabilized!-NTuple{6, Any}" href="#MultiScaleOT.sinkhorn_stabilized!-NTuple{6, Any}"><code>MultiScaleOT.sinkhorn_stabilized!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sinkhorn_stabilized!(a, b, μ, ν, K, ε; kwargs...)</code></pre><p>Implement the stabilized Sinkhorn algorithm of https://arxiv.org/abs/1610.06519.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.template_schedule-Union{Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}}} where T" href="#MultiScaleOT.template_schedule-Union{Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}}} where T"><code>MultiScaleOT.template_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">template_schedule(depth, template, factors; last_iter = [])</code></pre><p>Generate the vector <code>[factors[1].*template; ... ; factors[depth].*template; last_iter]</code> Useful to define a schedule with a certain substructure.  When <code>factors</code> is a singleton, it is transformed into <code>fill(factors, depth)</code>. When <code>template</code> is an <code>Int</code>, it is transformed into <code>ones(template)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; depth = 3; Ns = [1, 2, 4]; Nsteps = 2;
julia&gt; template_schedule(depth, Nsteps, Ns)
6-element Vector{Int64}:
 1
 1
 2
 2
 4
 4

julia&gt; depth = 3; maxiters_template = [2000, 1000]; factor = 1;
julia&gt; template_schedule(depth, maxiters_template, factor)
6-element Vector{Int64}:
 2000
 1000
 2000
 1000
 2000
 1000</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.update_current_Y_marginal!-NTuple{5, Any}" href="#MultiScaleOT.update_current_Y_marginal!-NTuple{5, Any}"><code>MultiScaleOT.update_current_Y_marginal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_current_Y_marginal!(νK, v, KT, u, ν)</code></pre><p>Update the current Y marginal of the coupling and  return the error with respect to the true marginal <code>ν</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleOT.DEFAULT_PARAMETERS" href="#MultiScaleOT.DEFAULT_PARAMETERS"><code>MultiScaleOT.DEFAULT_PARAMETERS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">DEFAULT_PARAMETERS</code></pre><p>Default parameters for the multiscale routines</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/MultiScaleOT.jl.git">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Library</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 8 December 2021 08:43">Wednesday 8 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
